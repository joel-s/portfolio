#!/usr/bin/bash
#
# Find all the places someone's been assigned machine time.
#
# Run showalloc -h or showtimes -h for usage info.
#	 
# Whereami written by ???, edited for Starcat by ryan.johnson@west.sun.com,
# as whereami script.
#
# Joel.Sullivan 8/9/02: Add times at the beginning and then sort, to get a
# single chronological list rather than several lists.
#
# NOTE: This script is indented with 4-column tab characters.
#

# Config constants
CAL_SVR=dayrunner.west
if [ ! "${0%%*alloc}" ]; then
    # script name ends in alloc, use alloc calendars
	MACH_LST="sms_alloc sustaining"
else
	MACH_LST="xc4p11 xc8p13 xc17p13 xc30p13"
fi

VIEW=week

while getopts d opt; do
    case $opt in
    d)
        VIEW=day
        ;;
    esac
done
shift $(( $OPTIND - 1 ))

# Check for the correct command line usage.
if [ \( $# -ne 1 -a $# -ne 2 \) -o ! "${1##-*}" ]
then
	echo "usage: $0 [-d] [date] key"
	echo "       -d: show one day only"
	echo "       \"date\" is a day formatted mo/dy/yr (see dtcm_insert(1))"
	echo "       \"key\" is the text to search for in calendars"
	echo ""
	echo "       example: $0 joel"
	echo "       example: $0 10/31/02 xc17p13"
	echo "       example: $0 sunday xc17p13    # shows data for next week"
	exit 2
fi

# Save off the date and the search key.
if test $# -eq 1
then
	DATE="today"
	KEY="$1"
else
	DATE="$1"
	KEY="$2"
fi

# create tmp awk command file
echo "
# Save this appt header in case a match is made
# for this day.
{
	# If this is an appointment header save it in case
	# a match is found for this day and this header
	# needs to be printed.
	if (\$0 ~ /^Appointments/)
	{
		appt_hdr = \$0
		hdr_printed = 0
	} 

	# Found a match.
	else if (tolower(\$0) ~ tolower(\"$KEY\"))
	{
		# Print this day's header just once.
		if (!hdr_printed)
		{
			# Create abbreviated date for sorting
			split(appt_hdr, fields, \" for \")
			split(fields[2], d)
			date = sprintf(\"%s %02d %s\", substr(d[2],0,3), d[3], d[4])

			print date, \"    \", appt_hdr
			hdr_printed = 1
			
		}

		# Convert to military time for sorting
		split(\$2, time, \":\")
		if (\$2 ~ /pm-/) {
			time[1] = time[1] + 12
		}
		if (\$2 ~ /^12/) {
			time[1] = time[1] - 12
		}
		
		# Print the match.
		printf(\"%s %02d:%02d     %-50s <%s>\\\n\", \
			date, time[1], time[2], substr(\$0,6), machine)
	}
} " > /tmp/showtimes.awk.$$

# hack so that dtcm_lookup can not find the users .desksetdefaults file and
# screw up the format of things like the date separator
HOME=/.$$.hack.$$.
export HOME

for MACHINE in $MACH_LST
do
	dtcm_lookup -d $DATE -v $VIEW -c ${MACHINE}@${CAL_SVR} | 
		nawk -f /tmp/showtimes.awk.$$ machine=$MACHINE >> /tmp/showtimes.$$
done

# Sort by date/time and eliminate duplicate "Appointemtns for..." lines
sort -k 3n -k 1M -k 2n -k 4n /tmp/showtimes.$$ | uniq | cut -c 19- |
	sed -e 's/^Appointments for /\
/'
echo

# clean up tmp files
rm -f /tmp/showtimes.awk.$$
rm -f /tmp/showtimes.$$
